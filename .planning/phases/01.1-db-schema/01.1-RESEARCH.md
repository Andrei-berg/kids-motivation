# Phase 1.1: db-schema - Research

**Researched:** 2026-03-01
**Domain:** Supabase PostgreSQL multi-tenant schema, Row Level Security, Supabase Auth, data migration
**Confidence:** HIGH

<phase_requirements>
## Phase Requirements

| ID | Description | Research Support |
|----|-------------|-----------------|
| REQ-AUTH-001 | Registration via email + password | Supabase Auth signUp() with email/password — standard pattern |
| REQ-AUTH-002 | Google OAuth login | Supabase Auth signInWithOAuth(provider: 'google') — needs Dashboard config |
| REQ-AUTH-004 | Password reset via email | Supabase Auth resetPasswordForEmail() — built-in |
| REQ-AUTH-005 | Session persists between opens | @supabase/ssr cookies-based session — automatic |
| REQ-AUTH-006 | Logout with session clear | supabase.auth.signOut() — built-in |
| REQ-AUTH-007 | Route guard — unauthenticated → /login | middleware.ts with updateSession + getUser() redirect |
| REQ-AUTH-008 | Middleware redirects to onboarding if no family | middleware.ts checks family_members table after auth |
| REQ-FAM-001 | Family creation (name, avatar) | families table with name/avatar_url columns |
| REQ-FAM-002 | Unique 6-char invite code per family | TEXT UNIQUE + substr(md5(random()::text), 1, 6) default |
| REQ-FAM-003 | Join family by code | families.invite_code lookup + insert into family_members |
| REQ-FAM-004 | Roles: parent / child / extended | family_members.role CHECK constraint |
| REQ-FAM-005 | Unlimited children | family_members rows with role='child' — no limit in schema |
| REQ-FAM-007 | Each member is separate account (email/Google) | auth.users → user_profiles → family_members hierarchy |
| REQ-FAM-013 | RLS — family A cannot see family B data | family_id in (SELECT family_id FROM family_members WHERE user_id = auth.uid()) |
| REQ-SEC-001 | RLS on all Supabase tables | ALTER TABLE ... ENABLE ROW LEVEL SECURITY on every table |
| REQ-SEC-005 | No public child profiles | RLS policies use authenticated role only, never public |
</phase_requirements>

---

## Summary

Phase 1.1 is the foundational database architecture change. The current app uses a completely public Supabase schema with TEXT primary keys ('adam', 'alim') and no authentication. This phase replaces that with a multi-tenant architecture: auth.users (Supabase Auth), user_profiles, families, and family_members as the identity spine, with every existing table gaining a family_id UUID column and proper RLS policies.

The key technical challenge is threefold: (1) create new auth and family tables, (2) migrate existing adam/alim data by creating a seed family and linking it, and (3) write RLS policies that use the optimized `family_id IN (SELECT family_id FROM family_members WHERE user_id = (select auth.uid()))` pattern. All 28 existing tables need family_id added and RLS enabled — this is high surface area but mechanically straightforward.

The current `lib/supabase.ts` only exports a single anonymous client. After this phase, the codebase needs three client factories: browser (createBrowserClient), server (createServerClient with cookies), and the middleware updateSession utility. This is a prerequisite for all subsequent phases and must be complete before any UI work starts.

**Primary recommendation:** Write a single `supabase/schema-v3.sql` migration file that: (1) creates auth/family tables, (2) adds family_id + user_id to all existing tables, (3) writes a seed migration to preserve adam/alim data, (4) drops all public-access policies, (5) installs correct RLS policies using the optimized membership check pattern.

---

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| @supabase/supabase-js | ^2.39.0 (already installed) | Database client, Auth calls | Already in project, do not upgrade during this phase |
| @supabase/ssr | latest (~0.5.x) | Cookie-based session for Next.js SSR/middleware | Required for App Router auth — replaces old @supabase/auth-helpers-nextjs |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| @supabase/auth-helpers-nextjs | DEPRECATED | Old auth helper | Do NOT use — project should use @supabase/ssr |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| @supabase/ssr | @supabase/auth-helpers-nextjs | auth-helpers is deprecated; ssr is the current standard |
| Text invite codes (substr(md5(random()))) | UUID invite codes | Text codes are human-friendly (6 chars); UUID codes would frustrate users |
| JWT custom claims for family_id | Join table lookup in RLS | JWT claims require Auth hooks; join table is simpler and works with getUser() |

**Installation:**
```bash
npm install @supabase/ssr
```

---

## Architecture Patterns

### Recommended File Structure (additions to existing project)
```
lib/
├── supabase/
│   ├── client.ts          # Browser client (createBrowserClient)
│   ├── server.ts          # Server Component client (createServerClient + cookies)
│   └── middleware.ts      # updateSession helper (token refresh + cookie sync)
middleware.ts              # Root-level Next.js middleware (route guard)
supabase/
├── schema-v3.sql          # Full new schema (new tables + migrations)
├── rls.sql                # All RLS policies (separate for clarity)
└── seed-migration.sql     # Preserve adam/alim data with new family
```

### Pattern 1: Three Supabase Client Factories

The current project has one anonymous `supabase` export. Phase 1.1 must replace/augment this with three distinct clients.

**What:** Browser, server, and middleware clients using @supabase/ssr
**When to use:** Browser client in 'use client' components; server client in Server Components and Route Handlers; middleware client only inside middleware.ts

```typescript
// lib/supabase/client.ts — for 'use client' components
// Source: https://supabase.com/docs/guides/auth/server-side/creating-a-client
import { createBrowserClient } from '@supabase/ssr'

export function createClient() {
  return createBrowserClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
  )
}
```

```typescript
// lib/supabase/server.ts — for Server Components, Route Handlers, Server Actions
// Source: https://supabase.com/docs/guides/auth/server-side/creating-a-client
import { createServerClient } from '@supabase/ssr'
import { cookies } from 'next/headers'

export async function createClient() {
  const cookieStore = await cookies()
  return createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return cookieStore.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) =>
            cookieStore.set(name, value, options)
          )
        },
      },
    }
  )
}
```

### Pattern 2: Next.js Middleware for Route Protection

**What:** middleware.ts intercepts every request, refreshes auth token, redirects unauthenticated users to /login, redirects authenticated users without a family to /onboarding.
**When to use:** Root-level middleware.ts — runs on every non-static request.

```typescript
// middleware.ts
// Source: https://supabase.com/docs/guides/auth/server-side/nextjs
import { type NextRequest, NextResponse } from 'next/server'
import { createServerClient } from '@supabase/ssr'

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({ request })

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() { return request.cookies.getAll() },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value }) => request.cookies.set(name, value))
          supabaseResponse = NextResponse.next({ request })
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          )
        },
      },
    }
  )

  // CRITICAL: use getUser(), never getSession() in middleware
  const { data: { user } } = await supabase.auth.getUser()

  const isPublicPath = request.nextUrl.pathname.startsWith('/login') ||
    request.nextUrl.pathname.startsWith('/register') ||
    request.nextUrl.pathname.startsWith('/auth')

  if (!user && !isPublicPath) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // Check for family membership — redirect to onboarding if missing
  if (user && !isPublicPath && !request.nextUrl.pathname.startsWith('/onboarding')) {
    const { data: membership } = await supabase
      .from('family_members')
      .select('id')
      .eq('user_id', user.id)
      .maybeSingle()

    if (!membership) {
      const url = request.nextUrl.clone()
      url.pathname = '/onboarding/welcome'
      return NextResponse.redirect(url)
    }
  }

  return supabaseResponse
}

export const config = {
  matcher: ['/((?!_next/static|_next/image|favicon.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp)$).*)'],
}
```

### Pattern 3: RLS Multi-Tenant Isolation

**What:** Every table has family_id. RLS policy checks family membership via join to family_members.
**When to use:** All tables that contain child/family data.

```sql
-- Source: https://supabase.com/docs/guides/database/postgres/row-level-security
-- Source: https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv

-- OPTIMIZED pattern: filter family_id against a subquery of user's families
-- The (select auth.uid()) wrapping caches the result per-statement, not per-row
CREATE POLICY "Family members only" ON days
  FOR ALL
  TO authenticated
  USING (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  )
  WITH CHECK (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  );

-- Required index for performance (100x improvement on large tables)
CREATE INDEX idx_family_members_user_id ON family_members(user_id);
CREATE INDEX idx_days_family_id ON days(family_id);
```

### Pattern 4: Auth Trigger for Automatic Profile Creation

**What:** PostgreSQL trigger fires after every new auth.users insert, creating a corresponding user_profiles row.
**When to use:** Setup once in schema — ensures profile always exists for any auth user.

```sql
-- Source: https://supabase.com/docs/guides/auth/managing-user-data
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.user_profiles (id, display_name, avatar_url)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', NEW.email),
    NEW.raw_user_meta_data->>'avatar_url'
  );
  RETURN NEW;
END;
$$;

CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
```

### Pattern 5: Data Migration Strategy for adam/alim

**What:** Preserve existing adam/alim data by creating a "bootstrap family" and linking all existing rows to it.
**When to use:** Run once as part of schema-v3 migration, after new tables are created.

```sql
-- Step 1: Create the bootstrap family
DO $$
DECLARE
  v_family_id UUID := gen_random_uuid();
  v_adam_user_id UUID := gen_random_uuid();  -- placeholder until real auth user created
  v_alim_user_id UUID := gen_random_uuid();
BEGIN
  INSERT INTO families (id, name, invite_code)
  VALUES (v_family_id, 'Семья Адама и Алима', 'LEGACY');

  -- Step 2: Add adam and alim as family_members
  INSERT INTO family_members (id, family_id, user_id, role, display_name)
  VALUES
    (gen_random_uuid(), v_family_id, v_adam_user_id, 'child', 'Адам'),
    (gen_random_uuid(), v_family_id, v_alim_user_id, 'child', 'Алим');

  -- Step 3: Backfill family_id on all existing tables
  -- (repeat for each table that references child_id)
  UPDATE days SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE subject_grades SET family_id = v_family_id WHERE family_id IS NULL;
  -- ... etc for all 28 tables
END;
$$;
```

**CRITICAL NOTE:** The adam/alim TEXT IDs cannot be directly converted to UUIDs (they are names, not UUIDs). The migration strategy is:
1. Add `family_id UUID` column to all existing tables (initially nullable)
2. Add `child_member_id UUID` column alongside `child_id TEXT` (initially nullable)
3. Create the bootstrap family and family_members rows
4. Backfill `family_id` and `child_member_id` on all rows
5. The `child_id TEXT` column is kept for now (Phase 1.4 removes hardcodes in code)
6. Drop the old public-access RLS policies; install proper family-scoped ones

### Anti-Patterns to Avoid

- **Using `auth.uid()` without select wrapper in RLS:** `auth.uid() = user_id` executes per-row; use `(select auth.uid()) = user_id` to cache — verified 20x+ speedup.
- **Using `getSession()` in middleware:** Not guaranteed to validate JWT. Always use `getUser()` in middleware and Server Components.
- **Using `@supabase/auth-helpers-nextjs`:** Deprecated — the @supabase/ssr package is the current standard.
- **Single global supabase client:** The existing `lib/supabase.ts` exports one anonymous client. It must NOT be used in Server Components or middleware — they need cookie-aware clients.
- **Dropping child_id TEXT columns immediately:** Too risky — all existing TS code references `child_id: 'adam' | 'alim'`. Keep both columns during Phase 1.1; remove in Phase 1.4.
- **RLS with public role:** Current schema uses `PUBLIC READ/WRITE` policies — these MUST be dropped and replaced with `authenticated` role only policies.

---

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Session persistence + refresh | Custom JWT storage/refresh logic | @supabase/ssr updateSession | Handles cookie sync between middleware, server, browser |
| Google OAuth flow | Custom OAuth redirect/callback | supabase.auth.signInWithOAuth() + /auth/callback route | Handles PKCE, state, token exchange |
| Password reset | Custom email + token system | supabase.auth.resetPasswordForEmail() | Built into Supabase Auth |
| RLS user lookup | Custom user_id checks in every query | PostgreSQL RLS policies + auth.uid() | Enforced at DB level, cannot be bypassed |
| Invite code generation | Custom random string generator | `substr(md5(random()::text), 1, 6)` as SQL default | Built-in PostgreSQL, collision probability acceptable at family scale |
| Auth trigger for profile creation | Application-level profile creation | PostgreSQL trigger on auth.users | Atomic, cannot be skipped if client crashes |

**Key insight:** Supabase provides all auth and security primitives. The entire auth system for this phase is configuration + SQL, not custom application code.

---

## Common Pitfalls

### Pitfall 1: Missing cookie handling in Server Components
**What goes wrong:** `createClient()` from the old `lib/supabase.ts` (anonymous client) used in Server Components — session not available, auth.uid() returns null, all RLS queries return empty.
**Why it happens:** Anonymous client has no cookie storage; Next.js Server Components need cookies for session.
**How to avoid:** Create `lib/supabase/server.ts` with `createServerClient` + cookie store. Remove the old `lib/supabase.ts` import from any Server Component.
**Warning signs:** Data queries return [] even though rows exist; auth.uid() returns null in RLS policies.

### Pitfall 2: getSession() in middleware
**What goes wrong:** Middleware uses `supabase.auth.getSession()` — session is not re-validated against Supabase Auth server, stale/expired tokens pass through.
**Why it happens:** getSession() reads from cookies only, does not call Auth server.
**How to avoid:** Always use `supabase.auth.getUser()` in middleware and Server Components.
**Warning signs:** Users with expired sessions can still access protected routes.

### Pitfall 3: RLS enabled but no policy for authenticated users
**What goes wrong:** Table has RLS enabled but policy is only for PUBLIC (the current schema) — after removing public policies and before adding auth policies, all queries return empty.
**Why it happens:** "Enable RLS" without a matching policy = deny all.
**How to avoid:** In the migration script, drop public policies AND add authenticated policies in the same transaction.
**Warning signs:** After migration, the dashboard loads but shows no data.

### Pitfall 4: Middleware query on every request is too slow
**What goes wrong:** Middleware checks `family_members` for every request — 50ms+ database roundtrip on every page load.
**Why it happens:** Database query in middleware is synchronous on the hot path.
**How to avoid:** Cache family membership in a custom cookie after first login. Only query DB on the first request or when cookie is missing.
**Warning signs:** App feels slow, logs show middleware taking >100ms.

### Pitfall 5: Breaking existing adam/alim data
**What goes wrong:** Migration drops child_id TEXT column too early, breaking all existing TypeScript code that queries by `child_id = 'adam'`.
**Why it happens:** Schema change without coordinating with application code.
**How to avoid:** Phase 1.1 only ADDS columns (family_id, child_member_id). Never drops child_id until Phase 1.4 removes all TS references.
**Warning signs:** TypeScript compilation errors in api.ts after migration.

### Pitfall 6: Google OAuth redirect URI mismatch
**What goes wrong:** Google OAuth returns "redirect_uri_mismatch" error.
**Why it happens:** Authorized redirect URIs in Google Cloud Console don't match Supabase project callback URL.
**How to avoid:** Add `https://<project-ref>.supabase.co/auth/v1/callback` to Google Cloud Console Authorized redirect URIs. Add `http://localhost:3000/**` for local development.
**Warning signs:** OAuth flow starts but fails on redirect back to app.

### Pitfall 7: Auth trigger failure blocks signups
**What goes wrong:** The `on_auth_user_created` trigger throws an exception — new user signup fails completely.
**Why it happens:** Trigger errors in PostgreSQL roll back the entire transaction, including the auth.users insert.
**How to avoid:** Use EXCEPTION handling inside the trigger function; make the profile insert safe with ON CONFLICT DO NOTHING.
**Warning signs:** Signup returns 500 error or generic auth error.

---

## Code Examples

### Creating families table with invite code
```sql
-- Source: ARCHITECTURE.md (project decisions) + Supabase docs
CREATE TABLE families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  avatar_url TEXT,
  invite_code TEXT UNIQUE NOT NULL DEFAULT upper(substr(md5(random()::text), 1, 6)),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Index for invite code lookups (used during join flow)
CREATE INDEX idx_families_invite_code ON families(invite_code);
```

### Creating family_members with role constraint
```sql
-- Source: ARCHITECTURE.md (project decisions)
CREATE TABLE family_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL REFERENCES families(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('parent', 'child', 'extended')),
  display_name TEXT,
  avatar_url TEXT,
  birth_year INT,
  joined_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(family_id, user_id)
);

CREATE INDEX idx_family_members_user_id ON family_members(user_id);
CREATE INDEX idx_family_members_family_id ON family_members(family_id);
```

### Adding family_id to existing tables (migration pattern)
```sql
-- Source: Standard PostgreSQL ALTER TABLE pattern
-- Apply to ALL 28 existing tables
ALTER TABLE days ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE subject_grades ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE subjects_cache ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE home_exercises ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE exercise_types ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
-- ... repeat for all tables

-- Add indexes for RLS performance
CREATE INDEX idx_days_family_id ON days(family_id);
CREATE INDEX idx_subject_grades_family_id ON subject_grades(family_id);
-- ... repeat for all tables
```

### Standard RLS policy template
```sql
-- Source: https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv
-- Apply this pattern to EVERY table

-- Enable RLS
ALTER TABLE {table_name} ENABLE ROW LEVEL SECURITY;

-- Drop old public policies
DROP POLICY IF EXISTS "Public read access" ON {table_name};
DROP POLICY IF EXISTS "Public write access" ON {table_name};

-- New family-scoped policy
CREATE POLICY "{table_name}_family_isolation" ON {table_name}
  FOR ALL
  TO authenticated
  USING (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  )
  WITH CHECK (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  );
```

### Email + password signup pattern
```typescript
// Source: https://supabase.com/docs/reference/javascript/auth-signup
// Used in /register page
const { data, error } = await supabase.auth.signUp({
  email,
  password,
  options: {
    data: {
      name: displayName,  // passed to raw_user_meta_data, used by trigger
    },
    emailRedirectTo: `${location.origin}/auth/callback`,
  },
})
```

### OAuth callback route handler
```typescript
// app/auth/callback/route.ts
// Source: https://supabase.com/docs/guides/auth/social-login/auth-google
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)
    if (!error) return NextResponse.redirect(`${origin}${next}`)
  }

  return NextResponse.redirect(`${origin}/login?error=auth-failed`)
}
```

---

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| @supabase/auth-helpers-nextjs | @supabase/ssr | 2023-2024 | auth-helpers is deprecated; @supabase/ssr is the correct package |
| `getSession()` in middleware | `getUser()` in middleware | Supabase Auth security update | getSession() doesn't re-validate JWT; getUser() does |
| Single global supabase client | Three clients (browser/server/middleware) | Next.js App Router | App Router requires cookie-aware clients per context |
| Public access RLS policies (current schema) | authenticated-only + family_id isolation | Phase 1.1 (this phase) | No auth = no security |
| TEXT primary keys ('adam', 'alim') | UUID primary keys with family_id | Phase 1.1 (this phase) | Required for multi-tenancy |

**Deprecated/outdated in this project:**
- `lib/supabase.ts` single export: Needs to be split into `lib/supabase/client.ts`, `lib/supabase/server.ts`, `lib/supabase/middleware.ts`
- Current public-access RLS policies: Drop all `"Public read access"` and `"Public write access"` policies
- `CREATE POLICY "Public write access" ON children FOR ALL USING (true)` — this must be removed

---

## Open Questions

1. **How to handle the adam/alim → real auth users mapping**
   - What we know: adam and alim are TEXT IDs. Real users will have UUID auth.uid().
   - What's unclear: Will the real Adam and Alim users be created during Phase 1.1 or later? If later, the migration placeholder UUIDs won't match real auth.users rows.
   - Recommendation: Phase 1.1 creates placeholder UUIDs in family_members for adam/alim. The actual Supabase Auth user accounts for Adam and Alim are created manually via Supabase Dashboard during testing, then their real UUIDs replace the placeholders. This is a one-time admin operation.

2. **exercise_types table: global vs family-scoped**
   - What we know: exercise_types currently has no child_id and is global (e.g., "Бег", "Отжимания"). CODEBASE-ANALYSIS lists it as "МИГРИРОВАТЬ (добавить family_id)".
   - What's unclear: Should exercise types be global defaults that each family can add to, or fully family-scoped?
   - Recommendation: Add family_id as nullable. NULL = global default; non-null = family-specific override. This avoids duplicating the default list per family.

3. **settings table: global coin rules vs family-scoped**
   - What we know: Current settings table has global key-value pairs for coin amounts. ARCHITECTURE.md shows coin rules will be family-configurable.
   - What's unclear: Phase 1.1 scope — do we add family_id to settings now or in Phase 2.1 (coins engine)?
   - Recommendation: Add family_id to settings table in Phase 1.1 (just the column + RLS), but don't build the coin configuration UI until Phase 2.1. This avoids a second migration later.

4. **Middleware performance: DB query on every request**
   - What we know: Checking family_members on every request adds latency.
   - What's unclear: Exact performance impact at this scale (single family, small data).
   - Recommendation: For Phase 1.1, accept the DB query in middleware. If performance is a problem in later phases, cache family_id in a custom JWT claim via Auth hook or in a short-lived cookie.

---

## Existing Schema: Tables Requiring Migration

For the planner: all 28 existing tables need `family_id UUID` added. Here is the complete list from CODEBASE-ANALYSIS.md:

**Existing tables (add family_id):**
`children`, `days`, `subject_grades`, `subjects_cache`, `home_sports`, `sports_sections`, `section_attendance`, `goals`, `goal_log`, `weeks`, `streaks`, `badges`, `records`, `challenges`, `subjects`, `schedule`, `home_exercises`, `exercise_types`, `wallet` (currently named differently — see wallet-api types), `wallet_transactions`, `rewards`, `reward_purchases`, `coin_exchanges`, `cash_withdrawals`, `wallet_settings`, `p2p_transfers`, `expenses`, `expense_categories`, `sections`, `section_visits`

**Settings table special case:**
`settings` uses TEXT primary key (key-value store) — needs family_id added or a new `family_settings` table created.

**New tables to create:**
`families`, `family_members`, `user_profiles`

---

## Sources

### Primary (HIGH confidence)
- https://supabase.com/docs/guides/database/postgres/row-level-security - RLS patterns, auth.uid() usage, join table patterns
- https://supabase.com/docs/guides/troubleshooting/rls-performance-and-best-practices-Z5Jjwv - Performance optimization (select wrapper, security definer, indexes)
- https://supabase.com/docs/guides/auth/managing-user-data - Auth trigger pattern for user_profiles
- https://supabase.com/docs/guides/auth/server-side/creating-a-client - Three client patterns for Next.js App Router
- https://supabase.com/docs/guides/auth/server-side/nextjs - middleware.ts setup, updateSession
- ARCHITECTURE.md (project decisions) - families/family_members/user_profiles schema already designed
- CODEBASE-ANALYSIS.md (project analysis) - complete list of 28 tables to migrate

### Secondary (MEDIUM confidence)
- https://supabase.com/docs/guides/auth/social-login/auth-google - Google OAuth setup
- https://supabase.com/docs/guides/auth/quickstarts/nextjs - Auth quickstart patterns
- Multiple WebSearch results confirming: @supabase/ssr is the current package, getUser() over getSession() in middleware

### Tertiary (LOW confidence)
- Middleware performance: DB query per request — recommendation to cache in later phase is based on general performance principles, not benchmarked for this specific scale.

---

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Supabase docs confirmed @supabase/ssr, createServerClient patterns
- Architecture: HIGH - ARCHITECTURE.md already has the schema designed; RLS patterns verified from official docs
- Migration strategy: MEDIUM - The adam/alim → UUID migration is custom to this project; placeholder UUID approach is a design recommendation, not a documented Supabase pattern
- Pitfalls: HIGH - Auth trigger failure, getSession() in middleware, RLS deny-all are all documented in official Supabase troubleshooting guides

**Research date:** 2026-03-01
**Valid until:** 2026-04-01 (Supabase SSR patterns are stable; Auth API is unlikely to change)
