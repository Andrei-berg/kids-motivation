---
phase: 01.1-db-schema
plan: "03"
type: execute
wave: 2
depends_on:
  - "01.1-02"
files_modified:
  - middleware.ts
  - app/auth/callback/route.ts
autonomous: true
requirements:
  - REQ-AUTH-007
  - REQ-AUTH-008

must_haves:
  truths:
    - "Unauthenticated users visiting any protected route are redirected to /login"
    - "Authenticated users with no family membership are redirected to /onboarding/welcome"
    - "Authenticated users with a family membership pass through to their destination"
    - "OAuth callback at /auth/callback exchanges code for session and redirects to /dashboard"
    - "Static assets (_next/static, images, favicon) bypass middleware"
    - "Auth session cookie is refreshed on every request (token rotation)"
  artifacts:
    - path: "middleware.ts"
      provides: "Route guard — unauthenticated → /login, no family → /onboarding/welcome"
      contains: "getUser()"
    - path: "app/auth/callback/route.ts"
      provides: "OAuth code exchange handler for Google OAuth and email magic links"
      exports: ["GET"]
  key_links:
    - from: "middleware.ts"
      to: "lib/supabase/middleware.ts"
      via: "updateSession import"
      pattern: "updateSession"
    - from: "middleware.ts"
      to: "family_members table"
      via: "supabase.from('family_members').select('id').eq('user_id', user.id)"
      pattern: "family_members"
    - from: "app/auth/callback/route.ts"
      to: "lib/supabase/server.ts"
      via: "createClient() import"
      pattern: "exchangeCodeForSession"
---

<objective>
Create the root middleware.ts that guards all routes and the /auth/callback route handler that completes OAuth and email verification flows.

Purpose: Without middleware, all routes are publicly accessible — any URL works without login. This plan makes auth enforcement real: unauthenticated users can't access any app page.
Output: middleware.ts (route guard) + app/auth/callback/route.ts (OAuth code exchange).
</objective>

<execution_context>
@/Users/andrei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/01.1-db-schema/01.1-RESEARCH.md
@.planning/phases/01.1-db-schema/01.1-02-SUMMARY.md

<interfaces>
<!-- From lib/supabase/middleware.ts (created in Plan 02) -->
```typescript
export async function updateSession(request: NextRequest): Promise<{
  supabase: SupabaseClient,
  supabaseResponse: NextResponse,
  user: User | null
}>
```
updateSession returns the supabase client, the response with refreshed cookies, and the authenticated user (or null if not logged in).

<!-- Public routes that must NOT be protected -->
- /login
- /register
- /auth/callback (OAuth redirect target)
- /auth/* (any supabase auth routes)
- Static files: _next/static, _next/image, favicon.ico, *.svg, *.png, etc.

<!-- Protected routes (everything else) -->
- /dashboard, /wallet, /analytics, /wallboard, /expenses, /settings, /audit
- Any route not in the public list above

<!-- Onboarding routes — authenticated but family-check exempt -->
- /onboarding/* (user is logged in but creating their family)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create middleware.ts — route guard with auth and family membership check</name>
  <files>middleware.ts</files>
  <action>
Create `middleware.ts` at the project root (next to package.json). This is a Next.js edge middleware file.

**Key behaviors:**
1. Call `updateSession(request)` to refresh auth token and get current user
2. If no user AND not a public path → redirect to /login
3. If user exists AND not a public/onboarding path → check family_members table
4. If no family membership → redirect to /onboarding/welcome
5. Otherwise → pass through (return supabaseResponse to preserve cookies)

**Critical implementation notes from research:**
- MUST use `getUser()` not `getSession()` (getSession doesn't re-validate JWT)
- `updateSession` from lib/supabase/middleware.ts already calls getUser() internally
- Return `supabaseResponse` (not NextResponse.next()) to preserve the refreshed cookies
- The family_members check adds a DB roundtrip — acceptable for Phase 1.1 (optimization deferred to Phase 1.4 if needed)

```typescript
import { type NextRequest, NextResponse } from 'next/server'
import { updateSession } from '@/lib/supabase/middleware'

export async function middleware(request: NextRequest) {
  const { supabaseResponse, user, supabase } = await updateSession(request)

  const pathname = request.nextUrl.pathname

  // Public paths — no auth required
  const isPublicPath =
    pathname.startsWith('/login') ||
    pathname.startsWith('/register') ||
    pathname.startsWith('/auth') ||
    pathname === '/'

  // Onboarding paths — auth required but family-check exempt
  const isOnboardingPath = pathname.startsWith('/onboarding')

  // Not logged in + trying to access protected route → /login
  if (!user && !isPublicPath) {
    const url = request.nextUrl.clone()
    url.pathname = '/login'
    return NextResponse.redirect(url)
  }

  // Logged in but on a data route — check family membership
  if (user && !isPublicPath && !isOnboardingPath) {
    const { data: membership } = await supabase
      .from('family_members')
      .select('id')
      .eq('user_id', user.id)
      .maybeSingle()

    if (!membership) {
      // Authenticated but no family — go to onboarding
      const url = request.nextUrl.clone()
      url.pathname = '/onboarding/welcome'
      return NextResponse.redirect(url)
    }
  }

  // All checks passed — return the supabase response (preserves refreshed cookies)
  return supabaseResponse
}

export const config = {
  matcher: [
    /*
     * Match all request paths EXCEPT:
     * - _next/static (static files)
     * - _next/image (image optimization)
     * - favicon.ico
     * - Files with extensions (svg, png, jpg, jpeg, gif, webp, ico, css, js)
     */
    '/((?!_next/static|_next/image|favicon\\.ico|.*\\.(?:svg|png|jpg|jpeg|gif|webp|ico|css|js)$).*)',
  ],
}
```
  </action>
  <verify>
    <automated>cd /Users/andrei/Desktop/kids-motivation && npx tsc --noEmit 2>&1 | head -20 && echo "TSC PASSED"</automated>
  </verify>
  <done>middleware.ts exists at project root. Contains updateSession import from lib/supabase/middleware. Has isPublicPath and isOnboardingPath checks. Returns supabaseResponse (not NextResponse.next()). Has correct matcher config. TypeScript compilation passes.</done>
</task>

<task type="auto">
  <name>Task 2: Create app/auth/callback/route.ts — OAuth and email verification callback handler</name>
  <files>app/auth/callback/route.ts</files>
  <action>
Create `app/auth/callback/route.ts`. This is the Next.js Route Handler that Supabase redirects to after Google OAuth and email verification. It exchanges the auth code for a session.

This route handles:
- Google OAuth redirect (after user clicks "Sign in with Google")
- Email magic link verification (if used)
- Password reset confirmation

The route must be a GET handler that:
1. Reads the `code` query parameter from the URL
2. Calls `supabase.auth.exchangeCodeForSession(code)` to create the session
3. Redirects to `/dashboard` on success
4. Redirects to `/login?error=auth-failed` on failure

Also reads the optional `next` query param to support deep-link redirects (e.g., `/auth/callback?next=/settings`).

```typescript
import { NextResponse } from 'next/server'
import { createClient } from '@/lib/supabase/server'

export async function GET(request: Request) {
  const { searchParams, origin } = new URL(request.url)
  const code = searchParams.get('code')
  const next = searchParams.get('next') ?? '/dashboard'

  if (code) {
    const supabase = await createClient()
    const { error } = await supabase.auth.exchangeCodeForSession(code)

    if (!error) {
      // Successful auth — redirect to intended destination
      return NextResponse.redirect(`${origin}${next}`)
    }
  }

  // Something went wrong — redirect to login with error signal
  return NextResponse.redirect(`${origin}/login?error=auth-failed`)
}
```

**Important:** This route must be listed in the public paths in middleware.ts (it is — `/auth` prefix is already covered by `pathname.startsWith('/auth')`).

Also create a placeholder `/app/login/page.tsx` stub if it doesn't already exist — just enough to avoid a 404 when middleware redirects there. Check if it exists first:

```typescript
// app/login/page.tsx — STUB for Phase 1.2 (full login UI built there)
// This exists so middleware redirects don't 404 during Phase 1.1 testing.
'use client'

export default function LoginPage() {
  return (
    <div style={{ padding: '2rem', textAlign: 'center' }}>
      <h1>Login</h1>
      <p>Full login UI coming in Phase 1.2 (onboarding)</p>
    </div>
  )
}
```

Only create the stub if `app/login/page.tsx` does not already exist. Check with: `ls app/login/page.tsx 2>/dev/null`.

Similarly, create a stub for `/app/onboarding/welcome/page.tsx` if it does not exist (needed for the middleware onboarding redirect):

```typescript
// app/onboarding/welcome/page.tsx — STUB for Phase 1.2
'use client'

export default function OnboardingWelcomePage() {
  return (
    <div style={{ padding: '2rem', textAlign: 'center' }}>
      <h1>Welcome! Create your family</h1>
      <p>Full onboarding coming in Phase 1.2</p>
    </div>
  )
}
```
  </action>
  <verify>
    <automated>cd /Users/andrei/Desktop/kids-motivation && npx tsc --noEmit 2>&1 | head -20 && test -f app/auth/callback/route.ts && echo "ALL FILES EXIST"</automated>
  </verify>
  <done>app/auth/callback/route.ts exists with GET handler that calls exchangeCodeForSession and redirects to /dashboard or /login?error=auth-failed. app/login/page.tsx exists (stub or real). app/onboarding/welcome/page.tsx exists (stub or real). TypeScript compilation passes.</done>
</task>

</tasks>

<verification>
```bash
# Files exist
ls /Users/andrei/Desktop/kids-motivation/middleware.ts
ls /Users/andrei/Desktop/kids-motivation/app/auth/callback/route.ts
ls /Users/andrei/Desktop/kids-motivation/app/login/page.tsx
ls /Users/andrei/Desktop/kids-motivation/app/onboarding/welcome/page.tsx

# TypeScript clean
cd /Users/andrei/Desktop/kids-motivation && npx tsc --noEmit 2>&1 | grep "error TS" | wc -l

# Middleware uses updateSession (not getSession)
grep "updateSession\|getUser\|getSession" /Users/andrei/Desktop/kids-motivation/middleware.ts

# Callback route uses exchangeCodeForSession
grep "exchangeCodeForSession" /Users/andrei/Desktop/kids-motivation/app/auth/callback/route.ts
```
</verification>

<success_criteria>
1. middleware.ts exists at project root, imports updateSession from @/lib/supabase/middleware
2. Unauthenticated request to /dashboard → redirect to /login (verifiable by middleware logic inspection)
3. Authenticated request with no family_members row → redirect to /onboarding/welcome
4. /auth/callback route exists and calls exchangeCodeForSession
5. TypeScript compilation has no new errors
6. /login and /onboarding/welcome stubs exist to prevent 404s during testing
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-db-schema/01.1-03-SUMMARY.md` with:
- Files created: middleware.ts, app/auth/callback/route.ts, app/login/page.tsx (stub), app/onboarding/welcome/page.tsx (stub)
- Auth flow: unauthenticated → /login, authenticated no family → /onboarding/welcome, authenticated with family → pass through
- Note for Phase 1.2: login/register pages and full onboarding UI needed; these stubs prevent 404s during Phase 1.1 development
- Note: Google OAuth requires Supabase Dashboard config (Site URL + Redirect URLs) and Google Cloud Console (OAuth app + redirect URI). This is Phase 1.2 user setup.
- Performance deferral: The middleware family_members query runs on every authenticated request (~50ms per call). Optimization deferred to Phase 1.4 — cache family_id in a custom cookie or JWT claim to eliminate the per-request DB roundtrip.
</output>
