---
phase: 01.1-db-schema
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/schema-v3.sql
  - supabase/rls.sql
  - supabase/seed-migration.sql
autonomous: true
requirements:
  - REQ-FAM-001
  - REQ-FAM-002
  - REQ-FAM-003
  - REQ-FAM-004
  - REQ-FAM-005
  - REQ-FAM-007
  - REQ-FAM-013
  - REQ-SEC-001
  - REQ-SEC-005

must_haves:
  truths:
    - "New tables exist: user_profiles, families, family_members"
    - "Every existing table has a family_id UUID column (nullable during migration)"
    - "All existing tables have RLS enabled with authenticated-only family-scoped policies"
    - "Public read/write policies are dropped on all tables"
    - "adam/alim data preserved in a bootstrap family via seed-migration.sql"
    - "Auth trigger auto-creates user_profiles on new signup"
    - "Invite code is auto-generated (6 uppercase chars) and unique per family"
  artifacts:
    - path: "supabase/schema-v3.sql"
      provides: "New tables: user_profiles, families, family_members + auth trigger"
      contains: "CREATE TABLE families"
    - path: "supabase/rls.sql"
      provides: "RLS policies for all tables (existing + new)"
      contains: "family_isolation"
    - path: "supabase/seed-migration.sql"
      provides: "Adds family_id columns to existing tables + backfills adam/alim data"
      contains: "ALTER TABLE days ADD COLUMN IF NOT EXISTS family_id"
  key_links:
    - from: "family_members.user_id"
      to: "auth.users.id"
      via: "REFERENCES auth.users(id)"
      pattern: "REFERENCES auth\\.users\\(id\\)"
    - from: "rls.sql policies"
      to: "family_members lookup"
      via: "family_id IN (SELECT family_id FROM family_members WHERE user_id = (SELECT auth.uid()))"
      pattern: "SELECT auth\\.uid\\(\\)"
    - from: "seed-migration.sql"
      to: "existing tables"
      via: "ALTER TABLE ... ADD COLUMN IF NOT EXISTS family_id UUID"
      pattern: "ADD COLUMN IF NOT EXISTS family_id"
---

<objective>
Create three SQL migration files that transform the existing single-family public schema into a multi-tenant architecture with proper Row Level Security.

Purpose: Every subsequent phase depends on this foundation. Without family_id on all tables and proper RLS, any new user's data would be visible to all users.
Output: Three SQL files the developer pastes into Supabase SQL Editor: schema-v3.sql (new tables), rls.sql (security policies), seed-migration.sql (data migration).
</objective>

<execution_context>
@/Users/andrei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/ARCHITECTURE.md
@.planning/CODEBASE-ANALYSIS.md
@.planning/phases/01.1-db-schema/01.1-RESEARCH.md

<interfaces>
<!-- Existing tables in the database (from supabase-schema-v2.sql + migration files) -->
<!-- All need family_id UUID added in seed-migration.sql -->

Core tables (supabase-schema-v2.sql):
  children (id TEXT PRIMARY KEY — 'adam'/'alim', name, emoji, age, xp, level)
  settings (key TEXT PRIMARY KEY, value TEXT)
  days (id UUID, child_id TEXT REFERENCES children(id), date DATE, room_*, good_behavior, ...)
  subject_grades (id UUID, child_id TEXT, date DATE, subject TEXT, grade INT)
  subjects_cache (id UUID, child_id TEXT, subject TEXT, frequency INT)
  home_sports (id UUID, child_id TEXT, date DATE, running/exercises/outdoor_games/stretching BOOL)
  sports_sections (id UUID, child_id TEXT, name TEXT, active BOOL)
  section_attendance (id UUID, child_id TEXT, section_id UUID, date DATE, attended BOOL, coach_rating INT)
  goals (id UUID, child_id TEXT, title TEXT, target INT, current INT, active BOOL)
  goal_log (id UUID, goal_id UUID, child_id TEXT, date DATE, amount INT)
  weeks (id UUID, child_id TEXT, week_start DATE, finalized BOOL)
  streaks (id UUID, child_id TEXT, streak_type TEXT, current_count INT, best_count INT)
  badges (id UUID, child_id TEXT, badge_key TEXT, xp_reward INT, earned_at TIMESTAMP)
  records (id UUID, child_id TEXT, record_type TEXT, value INT)
  challenges (id UUID, child_id TEXT, title TEXT, reward INT, completed BOOL)

Flexible migration tables (supabase-migration-flexible.sql):
  subjects (id UUID, child_id TEXT, name TEXT, is_active BOOL)
  schedule (id UUID, child_id TEXT, day_of_week INT, subject_id UUID, room TEXT)
  exercise_types (id UUID, name TEXT, unit TEXT, is_active BOOL)  -- NO child_id, global
  home_exercises (id UUID, child_id TEXT, date DATE, exercise_type_id UUID, value INT)

Expenses migration tables (supabase-step3-expenses.sql):
  expense_categories (id UUID, name TEXT, icon TEXT, color TEXT)
  expenses (id UUID, child_id TEXT, category_id UUID, date DATE, amount NUMERIC, note TEXT)
  sections (id UUID, child_id TEXT, name TEXT, day_of_week INT, time TIME, active BOOL)
  section_visits (id UUID, section_id UUID, child_id TEXT, date DATE, visited BOOL, coach_score INT)

Wallet tables (created in Supabase directly, no SQL file exists):
  wallet (id UUID, child_id TEXT, coins INT, real_money NUMERIC)
  wallet_transactions (id UUID, child_id TEXT, type TEXT, coins INT, description TEXT)
  wallet_settings (id UUID, child_id TEXT, coin_to_rub NUMERIC)
  rewards (id UUID, child_id TEXT, title TEXT, price INT, type TEXT, active BOOL)
  reward_purchases (id UUID, reward_id UUID, child_id TEXT, status TEXT, coins_spent INT)
  coin_exchanges (id UUID, child_id TEXT, coins INT, rub_amount NUMERIC, status TEXT)
  cash_withdrawals (id UUID, child_id TEXT, amount NUMERIC, reason TEXT, status TEXT)
  p2p_transfers (id UUID, from_child TEXT, to_child TEXT, coins INT, status TEXT)
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create supabase/schema-v3.sql — new identity tables and auth trigger</name>
  <files>supabase/schema-v3.sql</files>
  <action>
Create the directory `supabase/` at the project root and write `supabase/schema-v3.sql`.

This file creates the three new identity tables and the auth trigger. It does NOT modify existing tables (that is seed-migration.sql). It should be run FIRST in Supabase SQL Editor.

The file must contain exactly:

1. **user_profiles table** — one row per auth user, auto-created by trigger:
```sql
CREATE TABLE IF NOT EXISTS public.user_profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  display_name TEXT NOT NULL DEFAULT '',
  avatar_url TEXT,
  timezone TEXT DEFAULT 'UTC',
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

2. **families table** — one row per family:
```sql
CREATE TABLE IF NOT EXISTS public.families (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  avatar_url TEXT,
  invite_code TEXT UNIQUE NOT NULL DEFAULT upper(substr(md5(random()::text), 1, 6)),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_families_invite_code ON families(invite_code);
```

3. **family_members table** — links users to families with roles:
```sql
CREATE TABLE IF NOT EXISTS public.family_members (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  family_id UUID NOT NULL REFERENCES families(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,
  role TEXT NOT NULL CHECK (role IN ('parent', 'child', 'extended')),
  display_name TEXT,
  avatar_url TEXT,
  birth_year INT,
  joined_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(family_id, user_id)
);
CREATE INDEX IF NOT EXISTS idx_family_members_user_id ON family_members(user_id);
CREATE INDEX IF NOT EXISTS idx_family_members_family_id ON family_members(family_id);
```

4. **Auth trigger** — fires after every new auth.users row, creates user_profiles automatically. Use SECURITY DEFINER + EXCEPTION handling to prevent trigger errors from blocking signups:
```sql
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER SET search_path = ''
AS $$
BEGIN
  INSERT INTO public.user_profiles (id, display_name, avatar_url)
  VALUES (
    NEW.id,
    COALESCE(NEW.raw_user_meta_data->>'name', split_part(NEW.email, '@', 1), 'User'),
    NEW.raw_user_meta_data->>'avatar_url'
  )
  ON CONFLICT (id) DO NOTHING;
  RETURN NEW;
EXCEPTION WHEN OTHERS THEN
  RETURN NEW;  -- Never block signup
END;
$$;

DROP TRIGGER IF EXISTS on_auth_user_created ON auth.users;
CREATE TRIGGER on_auth_user_created
  AFTER INSERT ON auth.users
  FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();
```

Add a SQL comment header explaining execution order: "Run this file FIRST. Then seed-migration.sql. Then rls.sql."
  </action>
  <verify>
    <automated>npx tsc --noEmit 2>&1 | head -5; test -f /Users/andrei/Desktop/kids-motivation/supabase/schema-v3.sql && echo "FILE EXISTS" || echo "MISSING"</automated>
  </verify>
  <done>supabase/schema-v3.sql exists. Contains CREATE TABLE for user_profiles, families, family_members with all constraints. Contains the auth trigger function with EXCEPTION handling and ON CONFLICT DO NOTHING.</done>
</task>

<task type="auto">
  <name>Task 2: Create supabase/seed-migration.sql — add family_id to all existing tables and backfill adam/alim data</name>
  <files>supabase/seed-migration.sql</files>
  <action>
Write `supabase/seed-migration.sql`. This file runs SECOND and does two things: (a) adds `family_id UUID` column (nullable, with FK) to every existing table, and (b) creates a bootstrap family for adam/alim data and backfills family_id.

**CRITICAL CONSTRAINT from research:** Do NOT drop the `child_id TEXT` column. All existing TypeScript code still uses `child_id = 'adam'` or `child_id = 'alim'`. Only add new columns — never remove old ones. Phase 1.4 removes the hardcodes.

**Part 1 — Add family_id to all existing tables** (use ALTER TABLE ... ADD COLUMN IF NOT EXISTS):
```sql
-- Tables from supabase-schema-v2.sql
ALTER TABLE children ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE settings ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE days ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE subject_grades ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE subjects_cache ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE home_sports ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE sports_sections ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE section_attendance ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE goals ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE goal_log ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE weeks ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE streaks ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE badges ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE records ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE challenges ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);

-- Tables from supabase-migration-flexible.sql
ALTER TABLE subjects ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE schedule ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE home_exercises ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
-- exercise_types: nullable family_id (NULL = global default, non-null = family override)
ALTER TABLE exercise_types ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);

-- Tables from supabase-step3-expenses.sql
ALTER TABLE expense_categories ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE expenses ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE sections ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE section_visits ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);

-- Wallet tables (created directly in Supabase)
ALTER TABLE wallet ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE wallet_transactions ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE wallet_settings ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE rewards ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE reward_purchases ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE coin_exchanges ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE cash_withdrawals ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
ALTER TABLE p2p_transfers ADD COLUMN IF NOT EXISTS family_id UUID REFERENCES families(id);
```

Add performance indexes for all new family_id columns (critical for RLS performance):
```sql
CREATE INDEX IF NOT EXISTS idx_days_family_id ON days(family_id);
CREATE INDEX IF NOT EXISTS idx_subject_grades_family_id ON subject_grades(family_id);
-- ... one index per table that has family_id
```

**Part 2 — Bootstrap family and backfill** (use DO $$ ... $$):
```sql
DO $$
DECLARE
  v_family_id UUID;
BEGIN
  -- Create bootstrap family for adam and alim
  INSERT INTO families (name, invite_code)
  VALUES ('Семья (bootstrap)', 'LEGACY')
  ON CONFLICT (invite_code) DO UPDATE SET name = 'Семья (bootstrap)'
  RETURNING id INTO v_family_id;

  -- Backfill family_id on all existing tables where child_id IN ('adam', 'alim')
  UPDATE children SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE settings SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE days SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE subject_grades SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE subjects_cache SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE home_sports SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE sports_sections SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE section_attendance SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE goals SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE goal_log SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE weeks SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE streaks SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE badges SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE records SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE challenges SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE subjects SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE schedule SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE home_exercises SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE expense_categories SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE expenses SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE sections SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE section_visits SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE wallet SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE wallet_transactions SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE wallet_settings SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE rewards SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE reward_purchases SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE coin_exchanges SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE cash_withdrawals SET family_id = v_family_id WHERE family_id IS NULL;
  UPDATE p2p_transfers SET family_id = v_family_id WHERE family_id IS NULL;

  RAISE NOTICE 'Bootstrap complete. Bootstrap family_id: %', v_family_id;
  RAISE NOTICE 'IMPORTANT: Save this UUID. You will need it to link real auth users to this family.';
END;
$$;
```

Add a SQL comment explaining that after running this, the developer must manually create Supabase Auth users for Adam and Alim via the Supabase Dashboard (Authentication → Users), then add them to family_members using the bootstrap family_id printed in the notice above.

Include a ready-to-use snippet for adding the real auth users to family_members after manual creation:
```sql
-- Run this AFTER creating auth users for Adam and Alim in Supabase Dashboard
-- Replace the UUIDs with the actual auth user IDs
/*
INSERT INTO family_members (family_id, user_id, role, display_name)
VALUES
  ('<BOOTSTRAP_FAMILY_ID>', '<ADAM_AUTH_USER_ID>', 'child', 'Адам'),
  ('<BOOTSTRAP_FAMILY_ID>', '<ALIM_AUTH_USER_ID>', 'child', 'Алим');
*/
```
  </action>
  <verify>
    <automated>test -f /Users/andrei/Desktop/kids-motivation/supabase/seed-migration.sql && grep -c "ADD COLUMN IF NOT EXISTS family_id" /Users/andrei/Desktop/kids-motivation/supabase/seed-migration.sql || echo "MISSING"</automated>
  </verify>
  <done>supabase/seed-migration.sql exists. Contains ALTER TABLE ... ADD COLUMN IF NOT EXISTS family_id for all 28+ existing tables. Contains DO $$ block that creates the bootstrap family and backfills all rows. Has indexes for all new family_id columns. Has commented-out snippet for adding real auth users to family_members.</done>
</task>

<task type="auto">
  <name>Task 3: Create supabase/rls.sql — drop public policies, install authenticated family-scoped policies</name>
  <files>supabase/rls.sql</files>
  <action>
Write `supabase/rls.sql`. This file runs THIRD (after schema-v3.sql and seed-migration.sql). It drops all existing public-access policies and installs authenticated-only family-scoped policies.

**Pattern to use for ALL data tables** (from research — optimized with select wrapper):
```sql
CREATE POLICY "{table}_family_isolation" ON {table}
  FOR ALL
  TO authenticated
  USING (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  )
  WITH CHECK (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  );
```

The file structure must be:

**Section 1 — Drop all existing public policies:**
```sql
-- Drop public read policies
DROP POLICY IF EXISTS "Public read access" ON children;
DROP POLICY IF EXISTS "Public read access" ON settings;
DROP POLICY IF EXISTS "Public read access" ON days;
-- ... all 15 tables from schema-v2 + flexible + expenses tables
DROP POLICY IF EXISTS "Public write access" ON children;
-- ... all write policies
```

**Section 2 — Enable RLS on new tables (existing tables already have it):**
```sql
ALTER TABLE user_profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE families ENABLE ROW LEVEL SECURITY;
ALTER TABLE family_members ENABLE ROW LEVEL SECURITY;

-- Also enable RLS on any tables that were created by migration files without RLS
ALTER TABLE subjects ENABLE ROW LEVEL SECURITY;
ALTER TABLE schedule ENABLE ROW LEVEL SECURITY;
ALTER TABLE exercise_types ENABLE ROW LEVEL SECURITY;
ALTER TABLE home_exercises ENABLE ROW LEVEL SECURITY;
ALTER TABLE expense_categories ENABLE ROW LEVEL SECURITY;
ALTER TABLE expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE sections ENABLE ROW LEVEL SECURITY;
ALTER TABLE section_visits ENABLE ROW LEVEL SECURITY;
ALTER TABLE wallet ENABLE ROW LEVEL SECURITY;
ALTER TABLE wallet_transactions ENABLE ROW LEVEL SECURITY;
ALTER TABLE wallet_settings ENABLE ROW LEVEL SECURITY;
ALTER TABLE rewards ENABLE ROW LEVEL SECURITY;
ALTER TABLE reward_purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE coin_exchanges ENABLE ROW LEVEL SECURITY;
ALTER TABLE cash_withdrawals ENABLE ROW LEVEL SECURITY;
ALTER TABLE p2p_transfers ENABLE ROW LEVEL SECURITY;
```

**Section 3 — user_profiles: user can read/update only their own row:**
```sql
CREATE POLICY "user_profiles_own" ON user_profiles
  FOR ALL TO authenticated
  USING (id = (SELECT auth.uid()))
  WITH CHECK (id = (SELECT auth.uid()));
```

**Section 4 — families: members can read; members can update (not insert — done via app logic):**
```sql
CREATE POLICY "families_member_read" ON families
  FOR SELECT TO authenticated
  USING (
    id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "families_member_write" ON families
  FOR UPDATE TO authenticated
  USING (
    id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
      AND role = 'parent'
    )
  );

-- Allow INSERT for family creation (new family has no members yet)
CREATE POLICY "families_insert" ON families
  FOR INSERT TO authenticated
  WITH CHECK (true);
```

**Section 5 — family_members: members can read family roster; only parents can insert/update/delete:**
```sql
CREATE POLICY "family_members_read" ON family_members
  FOR SELECT TO authenticated
  USING (
    family_id IN (
      SELECT family_id FROM family_members fm2
      WHERE fm2.user_id = (SELECT auth.uid())
    )
  );

CREATE POLICY "family_members_insert" ON family_members
  FOR INSERT TO authenticated
  WITH CHECK (
    -- User can add themselves to any family (joining by invite code)
    user_id = (SELECT auth.uid())
    OR
    -- Parents can add members to their family
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid()) AND role = 'parent'
    )
  );

CREATE POLICY "family_members_update_delete" ON family_members
  FOR ALL TO authenticated
  USING (
    family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid()) AND role = 'parent'
    )
  );
```

**Section 6 — All existing data tables** (apply the standard family_isolation policy to every table that has family_id):

Apply the standard family_isolation pattern to: children, settings, days, subject_grades, subjects_cache, home_sports, sports_sections, section_attendance, goals, goal_log, weeks, streaks, badges, records, challenges, subjects, schedule, home_exercises, expense_categories, expenses, sections, section_visits, wallet, wallet_transactions, wallet_settings, rewards, reward_purchases, coin_exchanges, cash_withdrawals, p2p_transfers.

For exercise_types (family_id is nullable — global defaults): slightly different policy — allow read if family_id IS NULL (global) OR family_id matches member's family:
```sql
CREATE POLICY "exercise_types_family_isolation" ON exercise_types
  FOR ALL TO authenticated
  USING (
    family_id IS NULL
    OR family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  )
  WITH CHECK (
    family_id IS NULL
    OR family_id IN (
      SELECT family_id FROM family_members
      WHERE user_id = (SELECT auth.uid())
    )
  );
```

Add a comment block at the top of the file: "IMPORTANT: This file must be run after schema-v3.sql and seed-migration.sql. Running it before seed-migration.sql will cause all existing data to become invisible (RLS deny-all until family_id is backfilled)."
  </action>
  <verify>
    <automated>test -f /Users/andrei/Desktop/kids-motivation/supabase/rls.sql && grep -c "family_isolation" /Users/andrei/Desktop/kids-motivation/supabase/rls.sql || echo "MISSING"</automated>
  </verify>
  <done>supabase/rls.sql exists. Contains DROP POLICY for all existing public policies. Contains ALTER TABLE ENABLE ROW LEVEL SECURITY for new tables. Contains family-scoped authenticated policies for all 30+ tables. exercise_types has the nullable family_id variant. Has order-of-execution warning at the top.</done>
</task>

</tasks>

<verification>
All three SQL files exist in supabase/ directory:
- supabase/schema-v3.sql — contains CREATE TABLE for user_profiles, families, family_members and the auth trigger
- supabase/seed-migration.sql — contains ALTER TABLE ADD COLUMN for all 28+ tables and the DO $$ backfill block
- supabase/rls.sql — contains DROP POLICY for all public policies and new family_isolation policies for all tables

Run to verify:
```bash
ls /Users/andrei/Desktop/kids-motivation/supabase/
grep -c "CREATE TABLE" supabase/schema-v3.sql
grep -c "ADD COLUMN IF NOT EXISTS family_id" supabase/seed-migration.sql
grep -c "family_isolation" supabase/rls.sql
```
</verification>

<success_criteria>
1. supabase/schema-v3.sql: 3 new tables defined (user_profiles, families, family_members), auth trigger with EXCEPTION handling
2. supabase/seed-migration.sql: family_id column added to all 28+ existing tables, bootstrap family created, all existing rows backfilled
3. supabase/rls.sql: all public policies dropped, authenticated family-scoped policies on all tables
4. TypeScript build still passes after adding these files (no TS changes in this plan)
5. SQL files have clear execution order comments
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-db-schema/01.1-01-SUMMARY.md` with:
- Files created: supabase/schema-v3.sql, supabase/seed-migration.sql, supabase/rls.sql
- Key decisions: family_id nullable (not forced NOT NULL until Phase 1.4), child_id TEXT kept, exercise_types nullable family_id for global defaults
- How to apply: Run schema-v3.sql first, then seed-migration.sql, then rls.sql in Supabase SQL Editor
- Bootstrap family note: After seed-migration, developer creates Adam/Alim auth users in Supabase Dashboard and runs the commented INSERT into family_members
</output>
