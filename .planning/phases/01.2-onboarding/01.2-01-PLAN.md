---
phase: 01.2-onboarding
plan: "01"
type: execute
wave: 1
depends_on: []
files_modified:
  - supabase/onboarding-patch.sql
  - lib/onboarding-api.ts
autonomous: false
requirements:
  - REQ-ONB-003
  - REQ-ONB-004
  - REQ-ONB-005
  - REQ-ONB-007
  - REQ-ONB-009
  - REQ-FAM-008
  - REQ-FAM-009

must_haves:
  truths:
    - "user_profiles table has onboarding_step column to persist wizard progress"
    - "Supabase Storage bucket 'avatars' exists for child photo uploads"
    - "Type-safe onboarding API functions are importable by wizard and join-flow pages"
  artifacts:
    - path: "supabase/onboarding-patch.sql"
      provides: "ALTER TABLE user_profiles ADD COLUMN onboarding_step; CREATE STORAGE BUCKET avatars"
      contains: "onboarding_step"
    - path: "lib/onboarding-api.ts"
      provides: "All DB operations for the onboarding wizard and child join flow"
      exports:
        - getOnboardingStep
        - saveParentProfile
        - createFamily
        - addChildToFamily
        - lookupFamilyByCode
        - joinFamilyAsChild
  key_links:
    - from: "lib/onboarding-api.ts"
      to: "supabase/schema-v3.sql tables"
      via: "user_profiles, families, family_members"
      pattern: "supabase.from\\('(user_profiles|families|family_members)'\\)"
---

<objective>
Lay the data and contract foundation for the entire onboarding phase: add onboarding_step persistence to user_profiles, configure the Supabase Storage avatars bucket, and create the typed onboarding API module that all wizard and join-flow pages will import.

Purpose: Plans 02-05 import from lib/onboarding-api.ts — defining contracts here eliminates "scavenger hunt" exploration by later executors.
Output: supabase/onboarding-patch.sql (run manually in Supabase SQL Editor) + lib/onboarding-api.ts (ready to import)
</objective>

<execution_context>
@/Users/andrei/.claude/get-shit-done/workflows/execute-plan.md
@/Users/andrei/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01.2-onboarding/01.2-CONTEXT.md
@.planning/phases/01.1-db-schema/01.1-01-SUMMARY.md
@.planning/phases/01.1-db-schema/01.1-02-SUMMARY.md

<interfaces>
<!-- From supabase/schema-v3.sql — tables the onboarding API writes to -->

families table:
  id           UUID PRIMARY KEY
  name         TEXT NOT NULL
  avatar_url   TEXT
  invite_code  TEXT UNIQUE (6 chars, uppercase)
  created_at   TIMESTAMPTZ
  updated_at   TIMESTAMPTZ

family_members table:
  id           UUID PRIMARY KEY
  family_id    UUID (FK → families.id)
  user_id      UUID (FK → auth.users.id)
  role         TEXT  -- 'parent' | 'child' | 'extended'
  display_name TEXT
  avatar_url   TEXT
  birth_year   INT
  joined_at    TIMESTAMPTZ
  UNIQUE(family_id, user_id)

user_profiles table (after this plan's SQL patch):
  id              UUID PRIMARY KEY (same as auth.users.id)
  display_name    TEXT
  avatar_url      TEXT
  timezone        TEXT
  onboarding_step INT DEFAULT 0  -- <-- added by this plan
  created_at      TIMESTAMPTZ
  updated_at      TIMESTAMPTZ

<!-- From lib/supabase/client.ts -->
export function createClient(): SupabaseClient  // use in 'use client' pages
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write onboarding-patch.sql — add onboarding_step column and avatars storage bucket</name>
  <files>supabase/onboarding-patch.sql</files>
  <action>
Create supabase/onboarding-patch.sql with two sections:

**Section 1 — user_profiles patch:**
```sql
ALTER TABLE public.user_profiles
  ADD COLUMN IF NOT EXISTS onboarding_step INT NOT NULL DEFAULT 0;
```
onboarding_step meaning: 0=not started, 1=profile saved, 2=family created, 3=child added, 4=invite sent (or skipped), 5=categories done, 6=complete.

**Section 2 — Storage bucket:**
```sql
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types)
VALUES (
  'avatars',
  'avatars',
  true,
  5242880,  -- 5 MB limit
  ARRAY['image/jpeg', 'image/png', 'image/webp', 'image/gif']
)
ON CONFLICT (id) DO NOTHING;

-- RLS policy: authenticated users can upload to their own folder
INSERT INTO storage.policies (name, bucket_id, operation, definition)
VALUES (
  'Avatar upload: auth users only',
  'avatars',
  'INSERT',
  '(auth.uid() IS NOT NULL)'
)
ON CONFLICT DO NOTHING;

INSERT INTO storage.policies (name, bucket_id, operation, definition)
VALUES (
  'Avatar read: public',
  'avatars',
  'SELECT',
  'true'
)
ON CONFLICT DO NOTHING;
```

Add a header comment explaining: "Run this file in Supabase SQL Editor AFTER schema-v3.sql. Safe to re-run (IF NOT EXISTS / ON CONFLICT)."

Add instructions at the bottom as a comment block: how to find the public URL for uploaded avatars (Project URL + /storage/v1/object/public/avatars/{path}).
  </action>
  <verify>
    <automated>grep -q "onboarding_step" /Users/andrei/Desktop/kids-motivation/supabase/onboarding-patch.sql && grep -q "avatars" /Users/andrei/Desktop/kids-motivation/supabase/onboarding-patch.sql && echo "PASS" || echo "FAIL"</automated>
  </verify>
  <done>File exists with onboarding_step ALTER TABLE and avatars bucket INSERT. Idempotent (IF NOT EXISTS / ON CONFLICT).</done>
</task>

<task type="auto" tdd="true">
  <name>Task 2: Create lib/onboarding-api.ts — typed DB operations for wizard and join flow</name>
  <files>lib/onboarding-api.ts</files>
  <behavior>
    - getOnboardingStep(userId): returns current step number (0 if profile row missing)
    - saveParentProfile(userId, { displayName }): upserts user_profiles.display_name and sets onboarding_step = 1
    - createFamily(userId, { name }): inserts into families, inserts parent family_members row, returns { familyId, inviteCode }
    - addChildToFamily(familyId, { displayName, birthYear, avatarUrl? }): inserts child into family_members with role='child', returns { memberId, inviteCode: family.invite_code }
    - lookupFamilyByCode(code: string): finds family by invite_code (case-insensitive), returns { familyId, name } or null
    - joinFamilyAsChild(familyId, userId, { displayName }): inserts family_members row with role='child', updates user_profiles.onboarding_step = 6
    - updateOnboardingStep(userId, step: number): sets user_profiles.onboarding_step = step
  </behavior>
  <action>
Create lib/onboarding-api.ts as a 'use client' compatible module (no next/headers imports — uses browser supabase client from lib/supabase/client.ts).

Import pattern:
```typescript
import { createClient } from '@/lib/supabase/client'
```

All functions are async and return typed results. Error handling: throw Error with descriptive message on Supabase errors (so wizard pages can catch and show toast).

Types to export:
```typescript
export interface ParentProfile {
  displayName: string
}

export interface FamilyCreateResult {
  familyId: string
  inviteCode: string
}

export interface ChildMember {
  memberId: string
  inviteCode: string
}

export interface FamilyLookup {
  familyId: string
  name: string
}
```

For createFamily: step = insert into families (name), then insert into family_members (family_id, user_id, role='parent', display_name from user_profiles). Update user_profiles.onboarding_step = 2.

For addChildToFamily: insert into family_members with role='child'. Then SELECT invite_code from families WHERE id = familyId. The invite_code IS the family's code — all family members share it (per schema design). After insert, call updateOnboardingStep(userId, 3) — but since child profiles are created by parent (not logged in as child), do NOT update user_profiles for the child's auth.uid. This step tracks the parent's progress, so call updateOnboardingStep for the parent's userId passed as a parameter.

Note: In the schema, each family has ONE invite_code (on the families table). Children join via this code. The "6-digit per-child invite code" from CONTEXT.md maps to the family invite_code — when a child enters it, they see all child profiles in that family and pick theirs.

For lookupFamilyByCode: UPPER(code.trim()) before querying, since families.invite_code is stored uppercase.
  </action>
  <verify>
    <automated>cd /Users/andrei/Desktop/kids-motivation && npx tsc --noEmit 2>&1 | grep -E "onboarding-api|error" | head -20; echo "TypeScript check done"</automated>
  </verify>
  <done>lib/onboarding-api.ts exports all 7 functions + 4 types. TypeScript compiles with no errors on this file. All functions use lib/supabase/client.ts createClient().</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Checkpoint: Verify SQL applied and API contracts compile</name>
  <action>Human verification step: run SQL in Supabase Dashboard, verify schema changes, confirm TypeScript compiles.</action>
  <what-built>supabase/onboarding-patch.sql ready to run + lib/onboarding-api.ts with full typed API for onboarding wizard</what-built>
  <how-to-verify>
1. Run supabase/onboarding-patch.sql in Supabase SQL Editor (Dashboard > SQL Editor)
2. Verify in Table Editor: user_profiles table now has onboarding_step column (INT, default 0)
3. Verify in Storage: "avatars" bucket appears in Storage section
4. Run: `npx tsc --noEmit` — should return 0 errors
  </how-to-verify>
  <resume-signal>Type "approved" once SQL applied and TypeScript passes, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
- supabase/onboarding-patch.sql is idempotent and contains onboarding_step addition + avatars bucket
- lib/onboarding-api.ts exports: getOnboardingStep, saveParentProfile, createFamily, addChildToFamily, lookupFamilyByCode, joinFamilyAsChild, updateOnboardingStep
- TypeScript build passes with 0 errors
- All functions import from lib/supabase/client (browser-safe, no server-only imports)
</verification>

<success_criteria>
1. SQL file exists and is safe to run in Supabase SQL Editor
2. user_profiles.onboarding_step column added after running SQL
3. avatars Storage bucket created after running SQL
4. lib/onboarding-api.ts: all 7 functions exported with correct TypeScript types
5. `npx tsc --noEmit` passes
</success_criteria>

<output>
After completion, create `.planning/phases/01.2-onboarding/01.2-01-SUMMARY.md`
</output>
